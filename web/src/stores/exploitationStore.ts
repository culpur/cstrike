/**
 * Exploitation Store - Manages exploitation results and real-time updates
 */

import { create } from 'zustand';
import type {
  ExploitationResult,
  Vulnerability,
  Shell,
  Credential,
  ExploitFile,
  TimelineEvent,
} from '@/types/exploitation';
import { generateId } from '@utils/index';

interface ExploitationStore {
  // State
  results: ExploitationResult[];
  activeExploitations: Set<string>;
  selectedResultId: string | null;

  // Actions
  addResult: (exploitId: string, target: string) => void;
  updateResultStatus: (
    exploitId: string,
    status: ExploitationResult['status']
  ) => void;
  addVulnerability: (exploitId: string, vulnerability: Vulnerability) => void;
  addShell: (exploitId: string, shell: Shell) => void;
  addCredential: (exploitId: string, credential: Credential) => void;
  addFile: (exploitId: string, file: ExploitFile) => void;
  addTimelineEvent: (exploitId: string, event: Omit<TimelineEvent, 'id' | 'timestamp'>) => void;
  completeExploitation: (exploitId: string) => void;
  failExploitation: (exploitId: string, error: string) => void;
  setSelectedResult: (id: string | null) => void;
  getResult: (exploitId: string) => ExploitationResult | undefined;
  clearResults: () => void;
}

export const useExploitationStore = create<ExploitationStore>((set, get) => ({
  // Initial state
  results: [],
  activeExploitations: new Set(),
  selectedResultId: null,

  // Actions
  addResult: (exploitId, target) =>
    set((state) => {
      // Check if result already exists
      if (state.results.some((r) => r.exploit_id === exploitId)) {
        return state;
      }

      const activeExploitations = new Set(state.activeExploitations);
      activeExploitations.add(exploitId);

      return {
        results: [
          ...state.results,
          {
            id: generateId(),
            exploit_id: exploitId,
            target,
            status: 'running',
            vulnerabilities: [],
            shells: [],
            credentials: [],
            files: [],
            timeline: [
              {
                id: generateId(),
                timestamp: Date.now(),
                type: 'info',
                message: `Exploitation started against ${target}`,
                phase: 'initialization',
              },
            ],
            started_at: Date.now(),
          },
        ],
        activeExploitations,
      };
    }),

  updateResultStatus: (exploitId, status) =>
    set((state) => ({
      results: state.results.map((r) =>
        r.exploit_id === exploitId ? { ...r, status } : r
      ),
    })),

  addVulnerability: (exploitId, vulnerability) =>
    set((state) => ({
      results: state.results.map((r) =>
        r.exploit_id === exploitId
          ? {
              ...r,
              vulnerabilities: [...r.vulnerabilities, vulnerability],
              timeline: [
                ...r.timeline,
                {
                  id: generateId(),
                  timestamp: Date.now(),
                  type: 'success',
                  message: `Vulnerability discovered: ${vulnerability.name} (${vulnerability.severity})`,
                  phase: 'discovery',
                  details: vulnerability,
                },
              ],
            }
          : r
      ),
    })),

  addShell: (exploitId, shell) =>
    set((state) => ({
      results: state.results.map((r) =>
        r.exploit_id === exploitId
          ? {
              ...r,
              shells: [...r.shells, shell],
              timeline: [
                ...r.timeline,
                {
                  id: generateId(),
                  timestamp: Date.now(),
                  type: 'success',
                  message: `Shell obtained: ${shell.type} on ${shell.host}:${shell.port}`,
                  phase: 'exploitation',
                  details: shell,
                },
              ],
            }
          : r
      ),
    })),

  addCredential: (exploitId, credential) =>
    set((state) => ({
      results: state.results.map((r) =>
        r.exploit_id === exploitId
          ? {
              ...r,
              credentials: [...r.credentials, credential],
              timeline: [
                ...r.timeline,
                {
                  id: generateId(),
                  timestamp: Date.now(),
                  type: 'success',
                  message: `Credential extracted: ${credential.username}`,
                  phase: 'post-exploitation',
                  details: credential,
                },
              ],
            }
          : r
      ),
    })),

  addFile: (exploitId, file) =>
    set((state) => ({
      results: state.results.map((r) =>
        r.exploit_id === exploitId
          ? {
              ...r,
              files: [...r.files, file],
              timeline: [
                ...r.timeline,
                {
                  id: generateId(),
                  timestamp: Date.now(),
                  type: 'info',
                  message: `File downloaded: ${file.path} (${file.size} bytes)`,
                  phase: 'post-exploitation',
                  details: file,
                },
              ],
            }
          : r
      ),
    })),

  addTimelineEvent: (exploitId, event) =>
    set((state) => ({
      results: state.results.map((r) =>
        r.exploit_id === exploitId
          ? {
              ...r,
              timeline: [
                ...r.timeline,
                {
                  ...event,
                  id: generateId(),
                  timestamp: Date.now(),
                },
              ],
            }
          : r
      ),
    })),

  completeExploitation: (exploitId) =>
    set((state) => {
      const activeExploitations = new Set(state.activeExploitations);
      activeExploitations.delete(exploitId);

      return {
        results: state.results.map((r) =>
          r.exploit_id === exploitId
            ? {
                ...r,
                status: 'completed',
                completed_at: Date.now(),
                timeline: [
                  ...r.timeline,
                  {
                    id: generateId(),
                    timestamp: Date.now(),
                    type: 'success',
                    message: 'Exploitation completed',
                    phase: 'completion',
                  },
                ],
              }
            : r
        ),
        activeExploitations,
      };
    }),

  failExploitation: (exploitId, error) =>
    set((state) => {
      const activeExploitations = new Set(state.activeExploitations);
      activeExploitations.delete(exploitId);

      return {
        results: state.results.map((r) =>
          r.exploit_id === exploitId
            ? {
                ...r,
                status: 'failed',
                completed_at: Date.now(),
                timeline: [
                  ...r.timeline,
                  {
                    id: generateId(),
                    timestamp: Date.now(),
                    type: 'error',
                    message: `Exploitation failed: ${error}`,
                    phase: 'completion',
                  },
                ],
              }
            : r
        ),
        activeExploitations,
      };
    }),

  setSelectedResult: (id) => set({ selectedResultId: id }),

  getResult: (exploitId) => {
    return get().results.find((r) => r.exploit_id === exploitId);
  },

  clearResults: () =>
    set({
      results: [],
      activeExploitations: new Set(),
      selectedResultId: null,
    }),
}));
